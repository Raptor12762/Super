<script lang="ts">
	// --- Logic ---
	import { cn, min_max } from '@lib/utils';
	import type { Props } from '..';
	import { ParticleError } from '../errors';
	import { onMount } from 'svelte';

	let {
		children,
		class: className,
		particleClass = $bindable(''),
		position = $bindable(undefined),

		// Catch-all
		...rest
	}: Props = $props();

	// Setup Particle's class
	let particleCls = $state(cn(particleClass, className));
	$effect(() => {
		particleCls = cn(particleClass, className);
	});

	// Make sure position is actually given
	if (position === undefined) {
		throw new ParticleError({
			name: 'NO_POSITION_GIVEN',
			message: 'When creating this particle component, no `position` prop was passed.',
			cause: `Current Position: ${position}`
		});
	}

	// Make sure position start's have been set
	if (position.start === undefined) {
		throw new ParticleError({
			name: 'INVALID_POSITION',
			message: 'No starting position was given in the `position` prop',
			cause: position
		});
	}

	// Make sure min/max has been set for start.x and start.y
	if (
		position.start.x === undefined ||
		position.start.y === undefined ||
		position.start.x.min === undefined ||
		position.start.x.max === undefined ||
		position.start.y.min === undefined ||
		position.start.y.max === undefined
	) {
		throw new ParticleError({
			name: 'INVALID_POSITION',
			message:
				'No min or max value was given for the starting position (x or y) in the `position` prop',
			cause: position
		});
	}

	// Make sure position end's have been set
	if (position.end === undefined) {
		throw new ParticleError({
			name: 'INVALID_POSITION',
			message: 'No ending position was given in the `position` prop',
			cause: position
		});
	}

	// Make sure min/max has been set for end.x and end.y
	if (
		position.end.x === undefined ||
		position.end.y === undefined ||
		position.end.x.min === undefined ||
		position.end.x.max === undefined ||
		position.end.y.min === undefined ||
		position.end.y.max === undefined
	) {
		throw new ParticleError({
			name: 'INVALID_POSITION',
			message:
				'No min or max value was given for the ending position (x or y) in the `position` prop',
			cause: position
		});
	}

	// Prevent rendering until we're sure we got everything
	let render: boolean = $state(false);
	let x: number | undefined = $state(undefined);
	let y: number | undefined = $state(undefined);

	let particleRef: HTMLDivElement | undefined = $state(undefined);

	onMount(() => {
		if (!particleRef) return;

		console.log('Particle position prop:', position);

		const { offsetWidth, offsetHeight } = particleRef.parentElement ?? {};
		if (!offsetWidth || !offsetHeight) return;

		// Remove any existing duration-* class temporarily
		const prevDuration = [...particleRef.classList].find((cls) => cls.startsWith('duration-'));
		if (prevDuration) particleRef.classList.remove(prevDuration);

		// Disable transition
		particleRef.style.transition = 'none';

		// Add type safety for start
		if (
			position.start?.x?.min === undefined ||
			position.start?.x?.max === undefined ||
			position.start?.y?.min === undefined ||
			position.start?.y?.max === undefined
		)
			return;

		// Set starting position
		x = min_max(position.start.x.min, position.start.x.max) * offsetWidth;
		y = min_max(position.start.y.min, position.start.y.max) * offsetHeight;
		particleRef.style.transform = `translate(${x}px, ${y}px)`;

		// Restore transition & animate to end
		requestAnimationFrame(() => {
			if (particleRef === undefined) return;

			particleRef.style.transition = '';
			if (prevDuration) particleRef.classList.add(prevDuration);

			// Type safety again for end
			if (
				position.end?.x?.min === undefined ||
				position.end?.x?.max === undefined ||
				position.end?.y?.min === undefined ||
				position.end?.y?.max === undefined
			)
				return;

			// Check X Delta
			if (position.end.x.as_delta) {
				x = (x ?? 0) + min_max(position.end.x.min, position.end.x.max) * offsetWidth;
			} else {
				x = min_max(position.end.x.min, position.end.x.max) * offsetWidth;
			}

			// Check Y Delta
			if (position.end.y.as_delta) {
				y = (y ?? 0) + min_max(position.end.y.min, position.end.y.max) * offsetHeight;
			} else {
				y = min_max(position.end.y.min, position.end.y.max) * offsetHeight;
			}

			particleRef.style.transform = `translate(${x}px, ${y}px)`;
		});
	});
</script>

<div bind:this={particleRef} class={particleCls}>
	{@render children?.()}
</div>

<!--@component
    Generated by SvelteForgeðŸ”¥
-->
